using System.Collections.Generic;
using System.IO;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ValueTypeGenerator
{
    [Generator]
    internal class ValueTypeGenerator : ISourceGenerator
    {
        #region Templates
        private const string AutGeneratedComment = "// <auto-generated />\r\n";
        private const string NameSpaceTemplate =
@"{0}
{1}
namespace {2}
{{
    {3}
}}";
        private const string NameSpaces =
@"using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

#nullable enable
";
        private const string ClassTemplate =
@"public partial class {0} : Comparer<{0}>, IComparable<{0}>, IEquatable<{0}?>, IEqualityComparer<{0}>, IEqualityComparer
{{
    public static {0} From({1})
    {{
        {0} temp = new {0}();
{2}
        temp.Validate();

        return temp;
    }}

    public override bool Equals(object? obj)
    {{
        return Equals(obj as {0});
    }}

    public bool Equals({0}? other)
    {{
        if (other is null)
        {{
            return false;
        }}

        // Optimization for a common success case.
        if (Object.ReferenceEquals(this, other))
        {{
            return true;
        }}

        // If run-time types are not exactly the same, return false.
        if (GetType() != other.GetType())
        {{
            return false;
        }}

        return {3};
    }}

    public new bool Equals(object? x, object? y)
    {{
        if (x is null && y is null)
        {{
            return true;
        }}
        else if (x is null || y is null)
        {{
            return false;
        }}

        return Equals(x as {0}, y as {0});
    }}

    public bool Equals({0}? x, {0}? y)
    {{
        if (x is null && y is null)
        {{
            return true;
        }}
        else if (x is null || y is null)
        {{
            return false;
        }}

        return x.Equals(y);
    }}

    public override int Compare({0}? x, {0}? y)
    {{
        if (x is null || y is null)
        {{
            return 0;
        }}
{4}        else
        {{
            return 0;
        }}
    }}

    public int CompareTo({0}? other)
    {{
        return Compare(this, other);
    }}

    public override int GetHashCode()
    {{
        return HashCode.Combine({5});
    }}

    public int GetHashCode([DisallowNull] {0} obj)
    {{
        return obj != null ? obj.GetHashCode() : -0;
    }}

    public int GetHashCode(object obj)
    {{
        return obj is {0} ? GetHashCode(obj) : -0;
    }}

    public static bool operator ==({0}? left, {0}? right)
    {{
        if (left is null)
        {{
            if (right is null)
            {{
                return true;
            }}

            // Only the left side is null.
            return false;
        }}

        // Equals handles case of null on right side.
        return left.Equals(right);
    }}

    public static bool operator !=({0}? left, {0}? right)
    {{
        return !(left == right);
    }}

    public static bool operator <({0} left, {0} right)
    {{
        return left.CompareTo(right) < 0;
    }}

    public static bool operator <=({0} left, {0} right)
    {{
        return left.CompareTo(right) <= 0;
    }}

    public static bool operator >({0} left, {0} right)
    {{
        return left.CompareTo(right) > 0;
    }}

    public static bool operator >=({0} left, {0} right)
    {{
        return left.CompareTo(right) >= 0;
    }}
}}";
        private const string SetPropertiesTemplate = "        temp.{0} = {1};";
        private const string FromParametersTemplate = "{0} {1}, ";
        private const string EqualsTemplate = "{0} == other.{0} && ";
        private const string HashCodeTemplate = "{0}, ";
        private const string CompareTemplate =
@"        else if (x.{0}.CompareTo(y.{0}) != 0)
        {{
            return x.{0}.CompareTo(y.{0});
        }}
";
        #endregion

        #region Diagnostic Descriptors
        //private static readonly DiagnosticDescriptor Error =
        //    new DiagnosticDescriptor(
        //id: "VTG001",
        //title: $"Class does not implement {nameof(IValueType)}",
        //messageFormat: $"Type {{0}} does not implement the needed {nameof(IValueType)} interface",
        //category: "Compilation",
        //defaultSeverity: DiagnosticSeverity.Error,
        //isEnabledByDefault: true);
        #endregion

        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            //if (!System.Diagnostics.Debugger.IsAttached)
            //{
            //    System.Diagnostics.Debugger.Launch();
            //}
#endif
            context.RegisterForSyntaxNotifications(() => new ValueTypeSyntaxReciever());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is ValueTypeSyntaxReciever reciever))
            {
                return;
            }

            foreach (ClassDeclarationSyntax valueType in reciever.ValueTypes)
            {
                //if (!valueType.ImplementsValueType())
                //{
                //    Location location = Location.Create(valueType.SyntaxTree, valueType.Identifier.Span);
                //    context.ReportDiagnostic(Diagnostic.Create(Error, location, valueType.Identifier.Text));
                //    continue;
                //}

                (string fileName, string generatedClass) = ProcessClass(valueType);

                context.AddSource(fileName, generatedClass);
            }
        }

        private static (string fileName, string generatedClass) ProcessClass(ClassDeclarationSyntax classSyntax)
        {
            List<PropertyDeclarationSyntax> properties = classSyntax.GetProperties();

            StringBuilder setProp = new StringBuilder();
            StringBuilder fromParams = new StringBuilder();
            StringBuilder equalChecks = new StringBuilder();
            StringBuilder compare = new StringBuilder();
            StringBuilder hashCode = new StringBuilder();

            int propCount = properties.Count;
            for (int i = 0; i < propCount; i++)
            {
                string name = properties[i].Identifier.Text;
                string nameLower = name.ToLower();
                setProp.AppendFormat(SetPropertiesTemplate, name, nameLower).AppendLine();
                fromParams.AppendFormat(FromParametersTemplate, properties[i].Type, nameLower);
                equalChecks.AppendFormat(EqualsTemplate, name);
                compare.AppendFormat(CompareTemplate, name);
                hashCode.AppendFormat(HashCodeTemplate, name);
            }

            fromParams.Remove(fromParams.Length - 2, 2);
            equalChecks.Remove(equalChecks.Length - 4, 4);
            hashCode.Remove(hashCode.Length - 2, 2);

            string generatedClass = string.Format(ClassTemplate, classSyntax.Identifier.Text, fromParams, setProp, equalChecks, compare, hashCode);
            string fileName = Path.GetFileNameWithoutExtension(classSyntax.SyntaxTree.FilePath);

            if (!(classSyntax.Parent is BaseNamespaceDeclarationSyntax baseNamespace))
            {
                return ($"{fileName}.g.cs", NameSpaces + generatedClass);
            }

            string namespaceName = baseNamespace.Name.ToString();
            generatedClass = string.Format(NameSpaceTemplate, AutGeneratedComment, NameSpaces, namespaceName, generatedClass);

            return ($"{fileName}.g.cs", generatedClass);
        }
    }
}
